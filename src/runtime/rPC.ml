module type S = sig
  (** The API that an RPC implementation library exports to the code generated by
      the capnp-ocaml schema compiler. *)

  module Payload : sig
    (** A read-only payload, used for both the function arguments as received
        by a service, or for the response message as received by the client.
        It contains a Cap'n'Proto struct and a set of references (corresponding to
        the CapDescriptor table). *)
    type 'a t
  end

  module Service : sig
    (** The type of a method provided by the server application code.
        This is used in the generated code for the service class type. *)
    type ('a, 'b) method_t
  end

  module Struct : sig
    (** A reference to a struct, which may not have arrived yet. *)
    type 'a t
  end

  module Capability : sig
    (** A reference to an interface, which may be remote. *)
    type 'a t

    (** A method on some instance, as seen by the client application code.
        This is typically an [('a t, interface_id, method_id)] tuple.
        Used in the generated client classes. *)
    type ('a, 'b) method_t
  end

  module Untyped : sig
    (** This module is only for use by the code generated by the capnp-ocaml
        schema compiler. The generated code provides type-safe wrappers for
        everything here. *)

    (** An 8-byte slice containing a untyped Cap'n'Proto read-only pointer. *)
    type pointer_r

    (** [content_of_payload t] is the pointer to the payload's content struct.
        The compiler uses this to implement the [of_payload] methods in the
        generated files. *)
    val content_of_payload : 'a Payload.t -> pointer_r

    (** An untyped method. This will typically be something like
        ['a Payload.t -> 'b Struct.t * 'b Lwt.t]. i.e. the result of
        calling an interface's method is a reference to the future result,
        which can be used for pipelining further requests, and a local
        promise for the message content of the result. *)
    type abstract_method_t

    (** Cast a method to [abstract_method_t]. Typically this will be the identity function.
        This is used in the generated code to ensure that all methods have the
        same type for the dispatch function. *)
    val abstract_method : ('a, 'b) Service.method_t -> abstract_method_t

    (** [bind_method t ~interface_id ~method_id] represents a reference to
        the [(interface_id, method_id)] method of [t]. Used to implement the
        methods in the generated client classes. *)
    val bind_method : _ Capability.t -> interface_id:Uint64.t -> method_id:int ->
      ('a, 'b) Capability.method_t

    (** [struct_field t i] is a reference to the struct found at pointer index [i]
        within the struct [t]. Used to implement the "_pipelined" accessors. *)
    val struct_field : 'a Struct.t -> int -> 'b Struct.t

    (** [capability_field t i] is a reference to the capability found at pointer index [i]
        within the struct [t]. Used to implement the "_pipelined" accessors. *)
    val capability_field : 'a Struct.t -> int -> 'b Capability.t

    (** [local dispatch] is a capability reference to a local service implemented by [dispatch].
        Used in the generated dispatch functions. *)
    val local :
      (interface_id:Uint64.t -> method_id:int -> abstract_method_t) ->
      'a Capability.t
  end
end

module None (M : MessageSig.S)
  : S with type Untyped.pointer_r = Message.ro M.Slice.t option
= struct
  (** A dummy RPC provider, for when the RPC features (interfaces) aren't needed. *)

  type untyped_struct = [`No_RPC_struct]
  type untyped_cap = [`No_RPC_cap]
  type untyped_payload = [`No_RPC_payload]

  module Struct = struct
    type 'a t = untyped_struct
  end

  module Capability = struct
    type 'a t = untyped_cap
    type ('a, 'b) method_t = Uint64.t * int
  end

  module Payload = struct
    type 'a t = untyped_payload
  end

  module Untyped = struct
    type pointer_r = Message.ro M.Slice.t option
    type abstract_method_t = untyped_payload -> untyped_struct

    let bind_method `No_RPC_cap ~interface_id ~method_id = (interface_id, method_id)
    let content_of_payload `No_RPC_payload = None

    let abstract_method x = x

    let struct_field `No_RPC_struct _ = `No_RPC_struct
    let capability_field `No_RPC_struct _ = `No_RPC_cap
    let local _ = `No_RPC_cap
  end

  module Service = struct
    type ('a, 'b) method_t = Untyped.abstract_method_t
  end
end
